import{$PROXY,$TRACK,getListener,batch,createSignal}from"solid-js";const $RAW=Symbol("store-raw"),$NODE=Symbol("store-node"),$HAS=Symbol("store-has"),$SELF=Symbol("store-self");function wrap$1(e){let t=e[$PROXY];if(!t&&(Object.defineProperty(e,$PROXY,{value:t=new Proxy(e,proxyTraps$1)}),!Array.isArray(e))){const r=Object.keys(e),o=Object.getOwnPropertyDescriptors(e);for(let n=0,s=r.length;n<s;n++){const s=r[n];o[s].get&&Object.defineProperty(e,s,{enumerable:o[s].enumerable,get:o[s].get.bind(t)})}}return t}function isWrappable(e){let t;return null!=e&&"object"==typeof e&&(e[$PROXY]||!(t=Object.getPrototypeOf(e))||t===Object.prototype||Array.isArray(e))}function unwrap(e,t=new Set){let r,o,n,s;if(r=null!=e&&e[$RAW])return r;if(!isWrappable(e)||t.has(e))return e;if(Array.isArray(e)){Object.isFrozen(e)?e=e.slice(0):t.add(e);for(let r=0,s=e.length;r<s;r++)n=e[r],(o=unwrap(n,t))!==n&&(e[r]=o)}else{Object.isFrozen(e)?e=Object.assign({},e):t.add(e);const r=Object.keys(e),a=Object.getOwnPropertyDescriptors(e);for(let p=0,i=r.length;p<i;p++)s=r[p],a[s].get||(n=e[s],(o=unwrap(n,t))!==n&&(e[s]=o))}return e}function getNodes(e,t){let r=e[t];return r||Object.defineProperty(e,t,{value:r=Object.create(null)}),r}function getNode(e,t,r){if(e[t])return e[t];const[o,n]=createSignal(r,{equals:!1,internal:!0});return o.$=n,e[t]=o}function proxyDescriptor$1(e,t){const r=Reflect.getOwnPropertyDescriptor(e,t);return r&&!r.get&&r.configurable&&t!==$PROXY&&t!==$NODE?(delete r.value,delete r.writable,r.get=()=>e[$PROXY][t],r):r}function trackSelf(e){getListener()&&getNode(getNodes(e,$NODE),$SELF)()}function ownKeys(e){return trackSelf(e),Reflect.ownKeys(e)}const proxyTraps$1={get(e,t,r){if(t===$RAW)return e;if(t===$PROXY)return r;if(t===$TRACK)return trackSelf(e),r;const o=getNodes(e,$NODE),n=o[t];let s=n?n():e[t];if(t===$NODE||t===$HAS||"__proto__"===t)return s;if(!n){const r=Object.getOwnPropertyDescriptor(e,t);!getListener()||"function"==typeof s&&!e.hasOwnProperty(t)||r&&r.get||(s=getNode(o,t,s)())}return isWrappable(s)?wrap$1(s):s},has:(e,t)=>t===$RAW||t===$PROXY||t===$TRACK||t===$NODE||t===$HAS||"__proto__"===t||(getListener()&&getNode(getNodes(e,$HAS),t)(),t in e),set:()=>!0,deleteProperty:()=>!0,ownKeys,getOwnPropertyDescriptor:proxyDescriptor$1};function setProperty(e,t,r,o=!1){if(!o&&e[t]===r)return;const n=e[t],s=e.length;void 0===r?(delete e[t],e[$HAS]&&e[$HAS][t]&&void 0!==n&&e[$HAS][t].$()):(e[t]=r,e[$HAS]&&e[$HAS][t]&&void 0===n&&e[$HAS][t].$());let a,p=getNodes(e,$NODE);if((a=getNode(p,t,n))&&a.$((()=>r)),Array.isArray(e)&&e.length!==s){for(let t=e.length;t<s;t++)(a=p[t])&&a.$();(a=getNode(p,"length",s))&&a.$(e.length)}(a=p[$SELF])&&a.$()}function mergeStoreNode(e,t){const r=Object.keys(t);for(let o=0;o<r.length;o+=1){const n=r[o];setProperty(e,n,t[n])}}function updateArray(e,t){if("function"==typeof t&&(t=t(e)),t=unwrap(t),Array.isArray(t)){if(e===t)return;let r=0,o=t.length;for(;r<o;r++){const o=t[r];e[r]!==o&&setProperty(e,r,o)}setProperty(e,"length",o)}else mergeStoreNode(e,t)}function updatePath(e,t,r=[]){let o,n=e;if(t.length>1){o=t.shift();const s=typeof o,a=Array.isArray(e);if(Array.isArray(o)){for(let n=0;n<o.length;n++)updatePath(e,[o[n]].concat(t),r);return}if(a&&"function"===s){for(let n=0;n<e.length;n++)o(e[n],n)&&updatePath(e,[n].concat(t),r);return}if(a&&"object"===s){const{from:n=0,to:s=e.length-1,by:a=1}=o;for(let o=n;o<=s;o+=a)updatePath(e,[o].concat(t),r);return}if(t.length>1)return void updatePath(e[o],t,[o].concat(r));n=e[o],r=[o].concat(r)}let s=t[0];"function"==typeof s&&(s=s(n,r),s===n)||void 0===o&&null==s||(s=unwrap(s),void 0===o||isWrappable(n)&&isWrappable(s)&&!Array.isArray(s)?mergeStoreNode(n,s):setProperty(e,o,s))}function createStore(...[e,t]){const r=unwrap(e||{}),o=Array.isArray(r);return[wrap$1(r),function(...e){batch((()=>{o&&1===e.length?updateArray(r,e[0]):updatePath(r,e)}))}]}function proxyDescriptor(e,t){const r=Reflect.getOwnPropertyDescriptor(e,t);return!r||r.get||r.set||!r.configurable||t===$PROXY||t===$NODE||(delete r.value,delete r.writable,r.get=()=>e[$PROXY][t],r.set=r=>e[$PROXY][t]=r),r}const proxyTraps={get(e,t,r){if(t===$RAW)return e;if(t===$PROXY)return r;if(t===$TRACK)return trackSelf(e),r;const o=getNodes(e,$NODE),n=o[t];let s=n?n():e[t];if(t===$NODE||t===$HAS||"__proto__"===t)return s;if(!n){const n=Object.getOwnPropertyDescriptor(e,t),a="function"==typeof s;if(!getListener()||a&&!e.hasOwnProperty(t)||n&&n.get){if(null!=s&&a&&s===Array.prototype[t])return(...e)=>batch((()=>Array.prototype[t].apply(r,e)))}else s=getNode(o,t,s)()}return isWrappable(s)?wrap(s):s},has:(e,t)=>t===$RAW||t===$PROXY||t===$TRACK||t===$NODE||t===$HAS||"__proto__"===t||(getListener()&&getNode(getNodes(e,$HAS),t)(),t in e),set:(e,t,r)=>(batch((()=>setProperty(e,t,unwrap(r)))),!0),deleteProperty:(e,t)=>(batch((()=>setProperty(e,t,void 0,!0))),!0),ownKeys,getOwnPropertyDescriptor:proxyDescriptor};function wrap(e){let t=e[$PROXY];if(!t){Object.defineProperty(e,$PROXY,{value:t=new Proxy(e,proxyTraps)});const r=Object.keys(e),o=Object.getOwnPropertyDescriptors(e),n=Object.getPrototypeOf(e),s=null!==e&&"object"==typeof e&&!Array.isArray(e)&&n!==Object.prototype;if(s){const e=Object.getOwnPropertyDescriptors(n);r.push(...Object.keys(e)),Object.assign(o,e)}for(let n=0,a=r.length;n<a;n++){const a=r[n];if(!s||"constructor"!==a){if(o[a].get){const r=o[a].get.bind(t);Object.defineProperty(e,a,{get:r,configurable:!0})}if(o[a].set){const r=o[a].set,n=e=>batch((()=>r.call(t,e)));Object.defineProperty(e,a,{set:n,configurable:!0})}}}}return t}function createMutable(e,t){return wrap(unwrap(e||{}))}function modifyMutable(e,t){batch((()=>t(unwrap(e))))}const $ROOT=Symbol("store-root");function applyState(e,t,r,o,n){const s=t[r];if(e===s)return;const a=Array.isArray(e);if(r!==$ROOT&&(!isWrappable(e)||!isWrappable(s)||a!==Array.isArray(s)||n&&e[n]!==s[n]))return void setProperty(t,r,e);if(a){if(e.length&&s.length&&(!o||n&&e[0]&&null!=e[0][n])){let t,r,a,p,i,c,l,y;for(a=0,p=Math.min(s.length,e.length);a<p&&(s[a]===e[a]||n&&s[a]&&e[a]&&s[a][n]===e[a][n]);a++)applyState(e[a],s,a,o,n);const u=new Array(e.length),f=new Map;for(p=s.length-1,i=e.length-1;p>=a&&i>=a&&(s[p]===e[i]||n&&s[a]&&e[a]&&s[p][n]===e[i][n]);p--,i--)u[i]=s[p];if(a>i||a>p){for(r=a;r<=i;r++)setProperty(s,r,e[r]);for(;r<e.length;r++)setProperty(s,r,u[r]),applyState(e[r],s,r,o,n);return void(s.length>e.length&&setProperty(s,"length",e.length))}for(l=new Array(i+1),r=i;r>=a;r--)c=e[r],y=n&&c?c[n]:c,t=f.get(y),l[r]=void 0===t?-1:t,f.set(y,r);for(t=a;t<=p;t++)c=s[t],y=n&&c?c[n]:c,r=f.get(y),void 0!==r&&-1!==r&&(u[r]=s[t],r=l[r],f.set(y,r));for(r=a;r<e.length;r++)r in u?(setProperty(s,r,u[r]),applyState(e[r],s,r,o,n)):setProperty(s,r,e[r])}else for(let t=0,r=e.length;t<r;t++)applyState(e[t],s,t,o,n);return void(s.length>e.length&&setProperty(s,"length",e.length))}const p=Object.keys(e);for(let t=0,r=p.length;t<r;t++)applyState(e[p[t]],s,p[t],o,n);const i=Object.keys(s);for(let t=0,r=i.length;t<r;t++)void 0===e[i[t]]&&setProperty(s,i[t],void 0)}function reconcile(e,t={}){const{merge:r,key:o="id"}=t,n=unwrap(e);return e=>{if(!isWrappable(e)||!isWrappable(n))return n;const t=applyState(n,{[$ROOT]:e},$ROOT,r,o);return void 0===t?e:t}}const producers=new WeakMap,setterTraps={get(e,t){if(t===$RAW)return e;const r=e[t];let o;return isWrappable(r)?producers.get(r)||(producers.set(r,o=new Proxy(r,setterTraps)),o):r},set:(e,t,r)=>(setProperty(e,t,unwrap(r)),!0),deleteProperty:(e,t)=>(setProperty(e,t,void 0,!0),!0)};function produce(e){return t=>{if(isWrappable(t)){let r;(r=producers.get(t))||producers.set(t,r=new Proxy(t,setterTraps)),e(r)}return t}}const DEV=void 0;export{$RAW,DEV,createMutable,createStore,modifyMutable,produce,reconcile,unwrap};